import { AutoNetworkConfigs, CnsSupportedNetworks, CryptoRecords, DnsRecord, DnsRecordType, EnsSupportedNetworks, EthersProvider, NamehashOptions, NamingServiceName, Provider, ResolutionMethod, SourceConfig, Web3Version0Provider, Web3Version1Provider } from './types/publicTypes';
/**
 * Blockchain domain Resolution library - Resolution.
 * @example
 * ```
 * import Resolution from '@unstoppabledomains/resolution';
 *
 * let resolution = new Resolution({ blockchain: {
 *        ens: {
 *           url: "https://mainnet.infura.io/v3/12351245223",
 *           network: "mainnet"
 *        }
 *      }
 *   });
 *
 * let domain = "brad.zil";
 * resolution.addr(domain, "eth").then(addr => console.log(addr));;
 * ```
 */
export default class Resolution {
    constructor({ sourceConfig, }?: {
        sourceConfig?: SourceConfig;
    });
    /**
     * AutoConfigure the blockchain network between different testnets for ENS and CNS
     * We make a "net_version" JSON RPC call to the blockchain either via url or with the help of given provider.
     * @param sourceConfig - configuration object for ens and cns
     * @returns configured Resolution object
     */
    static autoNetwork(sourceConfig: AutoNetworkConfigs): Promise<Resolution>;
    /**
     * Creates a resolution with configured infura id for ens and cns
     * @param infura - infura project id
     * @param networks - an optional object that describes what network to use when connecting ENS or CNS default is mainnet
     */
    static infura(infura: string, networks?: {
        ens?: {
            network: EnsSupportedNetworks;
        };
        cns?: {
            network: CnsSupportedNetworks;
        };
    }): Resolution;
    /**
     * Creates a resolution instance with configured provider
     * @param provider - any provider compatible with EIP-1193
     * @param networks - an optional object that describes what network to use when connecting ENS or CNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    static fromEip1193Provider(provider: Provider, networks?: {
        ens?: {
            network: EnsSupportedNetworks;
        };
        cns?: {
            network: CnsSupportedNetworks;
        };
    }): Resolution;
    /**
     * Create a resolution instance from web3 0.x version provider
     * @param provider - an 0.x version provider from web3 ( must implement sendAsync(payload, callback) )
     * @param networks - Ethereum network configuration
     * @see https://github.com/ethereum/web3.js/blob/0.20.7/lib/web3/httpprovider.js#L116
     */
    static fromWeb3Version0Provider(provider: Web3Version0Provider, networks?: {
        ens?: {
            network: EnsSupportedNetworks;
        };
        cns?: {
            network: CnsSupportedNetworks;
        };
    }): Resolution;
    /**
     * Create a resolution instance from web3 1.x version provider
     * @param provider - an 1.x version provider from web3 ( must implement send(payload, callback) )
     * @param networks - an optional object that describes what network to use when connecting ENS or CNS default is mainnet
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-core-helpers/types/index.d.ts#L165
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-providers-http/src/index.js#L95
     */
    static fromWeb3Version1Provider(provider: Web3Version1Provider, networks?: {
        ens?: {
            network: EnsSupportedNetworks;
        };
        cns?: {
            network: CnsSupportedNetworks;
        };
    }): Resolution;
    /**
     * Creates instance of resolution from provider that implements Ethers Provider#call interface.
     * This wrapper support only `eth_call` method for now, which is enough for all the current Resolution functionality
     * @param provider - provider object
     * @param networks - an optional object that describes what network to use when connecting ENS or CNS default is mainnet
     * @see https://github.com/ethers-io/ethers.js/blob/v4-legacy/providers/abstract-provider.d.ts#L91
     * @see https://github.com/ethers-io/ethers.js/blob/v5.0.4/packages/abstract-provider/src.ts/index.ts#L224
     * @see https://docs.ethers.io/ethers.js/v5-beta/api-providers.html#jsonrpcprovider-inherits-from-provider
     * @see https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
     */
    static fromEthersProvider(provider: EthersProvider, networks?: {
        ens?: {
            network: EnsSupportedNetworks;
        };
        cns?: {
            network: CnsSupportedNetworks;
        };
    }): Resolution;
    /**
     * Resolves given domain name to a specific currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker like BTC, ETH, ZIL
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an address
     */
    addr(domain: string, ticker: string): Promise<string>;
    /**
     * Read multi-chain currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker (USDT, FTM, etc.)
     * @param chain - chain version, usually means blockchain ( ERC20, BEP2, OMNI, etc. )
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an adress
    */
    multiChainAddr(domain: string, ticker: string, chain: string): Promise<string>;
    /**
     * Resolves given domain name to a verified twitter handle
     * @async
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]] if twitter is not found
     * @returns A promise that resolves in a verified twitter handle
     */
    twitter(domain: string): Promise<string>;
    /**
     * Resolve a chat id from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns A promise that resolves in chatId
     */
    chatId(domain: string): Promise<string>;
    /**
     * Resolve a gundb public key from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns a promise that resolves in gundb public key
     */
    chatPk(domain: string): Promise<string>;
    /**
     * Resolves the IPFS hash configured for domain records on ZNS
     * @param domain - domain name
     * @throws [[ResolutionError]]
     */
    ipfsHash(domain: string): Promise<string>;
    /**
     * Resolves the httpUrl attached to domain
     * @param domain - domain name
     */
    httpUrl(domain: string): Promise<string>;
    /**
     * Resolves the ipfs email field from whois configurations
     * @param domain - domain name
     * @throws [[ResolutionError]]
     * @returns A Promise that resolves in an email address configured for this domain whois
     */
    email(domain: string): Promise<string>;
    /**
     * @returns the resolver address for a specific domain
     * @param domain - domain to look for
     */
    resolver(domain: string): Promise<string>;
    /**
     * @param domain - domain name
     * @returns An owner address of the domain
     */
    owner(domain: string): Promise<string | null>;
    /**
     * @param domain - domain name
     * @param recordKey - a name of a record to be resolved
     * @returns A record value promise for a given record name
     */
    record(domain: string, recordKey: string): Promise<string>;
    /**
     * @param domain domain name
     * @param keys Array of record keys to be resolved
     * @returns A Promise with key-value mapping of domain records
     */
    records(domain: string, keys: string[]): Promise<CryptoRecords>;
    /**
     * This method is only for ens at the moment. Reverse the ens address to a ens registered domain name
     * @async
     * @param address - address you wish to reverse
     * @param currencyTicker - currency ticker like BTC, ETH, ZIL
     * @returns Domain name attached to this address
     */
    reverse(address: string, currencyTicker: string): Promise<string | null>;
    /**
     * @returns Produces a namehash from supported naming service in hex format with 0x prefix.
     * Corresponds to ERC721 token id in case of Ethereum based naming service like ENS or CNS.
     * @param domain domain name to be converted
     * @param options formatting options
     * @throws [[ResolutionError]] with UnsupportedDomain error code if domain extension is unknown
     */
    namehash(domain: string, options?: NamehashOptions): string;
    /**
     * @returns a namehash of a subdomain with name label
     * @param parent namehash of a parent domain
     * @param label subdomain name
     * @param namingService "ENS", "CNS" or "ZNS"
     * @param options formatting options
     */
    childhash(parent: string, label: string, namingService: NamingServiceName, options?: NamehashOptions): string;
    private formatNamehash;
    /**
     * Checks weather the domain name matches the hash
     * @param domain - domain name to check againt
     * @param hash - hash obtained from the blockchain
     */
    isValidHash(domain: string, hash: string): boolean;
    /**
     * Checks if the domain name is valid according to naming service rules
     * for valid domain names.
     * Example: ENS doesn't allow domains that start from '-' symbol.
     * @param domain - domain name to be checked
     */
    isSupportedDomain(domain: string): boolean;
    /**
     * Returns the name of the service for a domain ENS | CNS | ZNS
     * @param domain - domain name to look for
     */
    serviceName(domain: string): ResolutionMethod;
    /**
     * Returns all record keys of the domain.
     * This method is strongly unrecommended for production use due to lack of support for many ethereum service providers and low performance
     * Method is not supported by ENS
     * @param domain - domain name
     */
    allRecords(domain: string): Promise<CryptoRecords>;
    dns(domain: string, types: DnsRecordType[]): Promise<DnsRecord[]>;
    private getDnsRecordKeys;
    private getPreferableNewRecord;
    private getNamingMethod;
    private getNamingMethodOrThrow;
    private prepareDomain;
}
export { Resolution };
