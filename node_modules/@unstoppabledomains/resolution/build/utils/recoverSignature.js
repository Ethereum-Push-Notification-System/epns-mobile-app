"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-undef */
var js_sha3_1 = require("js-sha3");
var _1 = require(".");
var configurationError_1 = __importStar(require("../errors/configurationError"));
var bytesLength = function (a) { return (a.length - 2) / 2; };
var bytesSlice = function (i, j, bs) {
    return '0x' + bs.slice(i * 2 + 2, j * 2 + 2);
};
var bytesToNumber = function (hex) { return parseInt(hex.slice(2), 16); };
var decodeSignature = function (hex) { return [
    bytesSlice(64, bytesLength(hex), hex),
    bytesSlice(0, 32, hex),
    bytesSlice(32, 64, hex),
]; };
var toChecksum = function (address) {
    var addressHash = js_sha3_1.keccak256(address.slice(2));
    var checksumAddress = '0x';
    for (var i = 0; i < 40; i++) {
        checksumAddress +=
            parseInt(addressHash[i + 2], 16) > 7
                ? address[i + 2].toUpperCase()
                : address[i + 2];
    }
    return checksumAddress;
};
var getSecp256k1 = function () {
    try {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        var elliptic = require('elliptic');
        var secp256k1 = new elliptic.ec('secp256k1');
        return secp256k1;
    }
    catch (err) {
        throw new configurationError_1.default(configurationError_1.ConfigurationErrorCode.DependencyMissing, { dependency: "elliptic", version: "^6.5.3" });
    }
};
exports.hashMessage = function (message) {
    var messageBytes = _1.hexToBytes(Buffer.from(message, 'utf8').toString('hex'));
    var messageBuffer = Buffer.from(messageBytes);
    var preamble = '\x19Ethereum Signed Message:\n' + messageBytes.length;
    var preambleBuffer = Buffer.from(preamble);
    var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);
    return '0x' + js_sha3_1.keccak256(ethMessage.toString());
};
exports.recover = function (message, signature) {
    var secp256k1 = getSecp256k1();
    var hash = exports.hashMessage(message);
    var vals = decodeSignature(signature);
    var vrs = {
        v: bytesToNumber(vals[0]),
        r: vals[1].slice(2),
        s: vals[2].slice(2),
    };
    var ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - (vrs.v % 2));
    var publicKey = '0x' + ecPublicKey.encode('hex', false).slice(2);
    var publicHash = '0x' + js_sha3_1.keccak256(_1.hexToBytes(publicKey));
    var address = toChecksum('0x' + publicHash.slice(-40));
    return address;
};
